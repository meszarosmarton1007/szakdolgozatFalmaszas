@model ClimbingApplication.Models.Utak

@{
    ViewData["Title"] = "Edit";
}

<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
</head>

<h1>Szerkesztés</h1>

<h4>Utak</h4>
<hr />
<div class="row">
    <div class="col-md-4">
         <button onclick="undo()" id="undoBtn">Visszavonás</button>
         <button onclick="redo()" id="redoBtn">Visszaállítás</button>
          <select id="colorPicker">
                    <option value="red">Piros</option>
                    <option value="blue">Kék</option>
                    <option value="green">Zöld</option>
                    <option value="black">Fekete</option>
                    <option value="white">Fehér</option>
                    <option value="yellow">Sárga</option>
                    <option value="orange">Narancssárga</option>
                </select>
        <form asp-action="Edit" id="editForm">
            <div asp-validation-summary="ModelOnly" class="text-danger"></div>
            <input type="hidden" asp-for="ID" />
            
            <div class="form-group">
                <input asp-for="kep" id="imgUrl" type="hidden"/>
                <input value="@Model.kep" id="oldImgUrl" type="hidden" />
                <span asp-validation-for="kep" class="text-danger"></span>
               
               
                <br />
                <canvas id="canvas" width="800" height="600"></canvas>
                    <input type="file" id="imageLoader" accept="image/*" />
            </div>
            <div class="form-group">
                <label asp-for="nehezseg" class="control-label"></label>
                <input asp-for="nehezseg" class="form-control" />
                <span asp-validation-for="nehezseg" class="text-danger"></span>
            </div>
            <div class="form-group">
                <label asp-for="nev" class="control-label"></label>
                <input asp-for="nev" class="form-control" />
                <span asp-validation-for="nev" class="text-danger"></span>
            </div>
            <div class="form-group">
                <label asp-for="leiras" class="control-label"></label>
                <textarea asp-for="leiras" class="form-control" ></textarea>
                <span asp-validation-for="leiras" class="text-danger"></span>
            </div>
            <div class="form-group">
                <label asp-for="letrehozva" class="control-label"></label>
                <input asp-for="letrehozva" class="form-control" type="date"/>
                <span asp-validation-for="letrehozva" class="text-danger"></span>
            </div>
            <div class="form-group">
               <label>Falon van</label>
               <input class="form-control" value="@Model.Falonut?.nev" disabled />
            </div>
                <div class="form-group">
                    <label>Létrehozó</label>
                    <input class="form-control" value="@Model.UtLetrehozo?.felhasznaloNev" disabled />
                </div>
            <div class="form-group">
                <input type="submit" value="Mentés" class="btn btn-primary" />
            </div>
        </form>
    </div>
</div>

<div>
        <a asp-controller="Utak" asp-action="Index" asp-route-falId="@ViewBag.FalId" class="btn btn-secondary">Vissza az utakhoz</a>
</div>

@section Scripts {
    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}

    <script>
        // --- GLOBÁLIS DEKLARÁCIÓK ---
        // DEKLARÁLJUK a canvas-t és a stack-eket, hogy a globális függvények (undo/redo) elérjék.
        let canvas; 
        let stateStack = [];
        let redoStack = [];
        let isRestorngState = false;
        const existingImageUrl = '@Html.Raw(Model.kep)'; 

        // --- GLOBÁLIS FÜGGVÉNYEK (A HTML onclick eléréséhez) ---

        function loadState(state) {
            isRestorngState = true;
            // A loadFromJSON aszinkron, ezért kell a callback
            canvas.loadFromJSON(state, () => {
                canvas.renderAll();
                isRestorngState = false;
            });
        }
        
        function saveState() {
            if (isRestorngState || !canvas) {
                return;
            }
            // JSON.stringify() a deep copy miatt, hogy ne mutasson a verem a canvas aktuális állapotára
            stateStack.push(JSON.stringify(canvas.toJSON())); 
            redoStack = [];
        }

        // Visszavonás funkció (a HTML onclick hívja)
        function undo() {
            if (!canvas) return; // Védelmi ellenőrzés
            if(stateStack.length > 1){
                redoStack.push(stateStack.pop());
                // Visszaállítjuk az UTOLSÓ ELŐTTI állapotot
                loadState(stateStack[stateStack.length - 1]);
            }
        }
        
        // Visszaállítás funkció (a HTML onclick hívja)
        function redo() {
            if (!canvas) return; // Védelmi ellenőrzés
            if (redoStack.length > 0) {
                const nextState = redoStack.pop();
                stateStack.push(nextState);
                loadState(nextState);
            }
        }
        
        // Kép vászonra illesztése (segédfüggvény)
        function setCanvasBackground(imageUrl) {
            if (!imageUrl || !canvas) return;

            fabric.Image.fromURL(imageUrl, function (img) {
                canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                    scaleX: canvas.width / img.width,
                    scaleY: canvas.height / img.height
                });
                // Első állapot mentése a háttérkép beállítása után
                saveState(); 
            }, { crossOrigin: 'anonymous' });
        }


        // --- DOMContentLoaded ESEMÉNYKEZELŐ (A vászon inicializálása itt történik) ---
        document.addEventListener("DOMContentLoaded", () => {
            // 1. A VÁSZON INICIALIZÁLÁSA
            canvas = new fabric.Canvas('canvas');
            
            const oldImageUrlInput = document.getElementById("oldImgUrl");
            const newImageUrlInput = document.getElementById("imgUrl");

            // 2. MEGLÉVŐ KÉP BETÖLTÉSE
            if (existingImageUrl) {
                setCanvasBackground(existingImageUrl);
            } else {
                // Ha nincs meglévő kép, a vászon üres állapotát mentjük kezdőállapotnak
                saveState();
            }

            // 3. ESEMÉNYKEZELŐK
            // Eseménykezelő a rajz befejezésére -> állapot mentése
            canvas.on('path:created', (options) => {
                saveState();
            });
            
            // ... a többi kód az eredeti Edit oldalból ...

            let currentColor = "red";
            document.getElementById("colorPicker").addEventListener("change", (e) => {
                currentColor = e.target.value;
                canvas.freeDrawingBrush.color = currentColor;
            });

            //rajzolás engedélyezése
            canvas.isDrawingMode = true
            canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
            canvas.freeDrawingBrush.width = 5;
            canvas.freeDrawingBrush.color = currentColor;

            const imageLoader = document.getElementById('imageLoader');
            imageLoader.addEventListener('change', function (e) {
                const reader = new FileReader();
                reader.onload = function (event) {
                    // ÚJ KÉP BETÖLTÉSEKOR TÖRLÖLJÜK A RÉGI TARTALMAT
                    canvas.clear(); 
                    stateStack = []; 
                    redoStack = [];
                    setCanvasBackground(event.target.result);
                };
                reader.readAsDataURL(e.target.files[0]);
            });


            //Új kép mentése
            function saveImage() {
                return new Promise((resolve, reject) => {
                    try {
                        const dataURL = canvas.toDataURL("image/png");
                        fetch('/api/feltoltes/saveimage', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ imageData: dataURL })
                        })
                            .then(async response => {
                                if (!response.ok) {
                                    const text = await response.text();
                                    throw new Error(text);
                                }
                                return response.json();
                            })
                            .then(data => {
                                newImageUrlInput.value = data.url;
                                console.log("Kép sikeresen feltöltve:", data.url);
                                resolve();
                            })
                            .catch(err => {
                                alert("Hiba történt a kép mentésekor:\n" + err.message);
                                reject(err);
                            });
                    } catch (err) {
                        console.error("Canvas export hiba:", err);
                        reject(err);
                    }
                });
            }

            //régi kép törlése
            function deleteOldImage() {
                return new Promise(async (resolve, reject) => {
                    const oldUrl = oldImageUrlInput.value;
                    if(!oldUrl){
                        resolve();
                        return;
                    }

                    try {
                        const url = new URL(oldUrl);
                        const path = url.pathname;
                        let filePath = decodeURIComponent(path.split('/o/')[1].split('?')[0]);
                        const response = await fetch(`/api/Feltoltes/deleteimage?fileName=${encodeURIComponent(filePath)}`, {
                            method: "DELETE"
                        });
                        if (response.ok) {
                            console.log("Régi kép törölve:", filePath);
                            resolve();
                        } else {
                            resolve(); 
                        }

                    } catch (err) {
                        console.warn("Hiba a törlés közben, de folytatom a mentést:", err);
                        resolve();
                    }
                });
            }

            //Form elküldés
            document.getElementById("editForm").addEventListener("submit", async function (e) {
                e.preventDefault();
                try {
                    // Ellenőrzi, hogy van-e rajz a vásznon (az első mentett állapoton felül)
                    const isCanvasModified = stateStack.length > 1; 
                    const oldUrl = oldImageUrlInput.value;

                    if (isCanvasModified || canvas.backgroundImage) {
                        if (oldUrl && isCanvasModified) {
                            await deleteOldImage();
                        }
                        await saveImage();
                    }

                    // Végül küldje el a formot
                    this.submit();
                } catch (err) {
                    console.log("Mentés megszakítva: ", err);
                    alert("Nem sikerült a kép frissítése");
                }
            });
        });
    </script>
}
